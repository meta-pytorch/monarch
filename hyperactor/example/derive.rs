/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree.
 */

use std::collections::HashSet;
use std::fmt::Debug;
use std::time::Duration;

use async_trait::async_trait;
use hyperactor::Actor;
use hyperactor::Context;
use hyperactor::HandleClient;
use hyperactor::Handler;
use hyperactor::Named;
use hyperactor::OncePortRef;
use hyperactor::RefClient;
use hyperactor::proc::Proc;
use serde::Deserialize;
use serde::Serialize;

#[derive(Handler, HandleClient, RefClient, Debug, Serialize, Deserialize, Named)]
enum ShoppingList {
    // Oneway messages dispatch messages asynchronously, with no reply.
    Add(String),
    Remove(String),

    // Call messages dispatch a request, expecting a reply to the
    // provided port, which must be in the last position.
    Exists(String, #[reply] OncePortRef<bool>),

    List(#[reply] OncePortRef<Vec<String>>),
}

// Example struct-based message types (demonstrating the new struct support)
#[derive(Handler, HandleClient, RefClient, Debug, Serialize, Deserialize, Named)]
struct ClearList {
    reason: String,
}

#[derive(Handler, HandleClient, RefClient, Debug, Serialize, Deserialize, Named)]
struct GetItemCount<C> {
    category_filter: String,
    #[reply]
    reply: OncePortRef<C>,
}

// Define an actor.
#[derive(Debug, Actor, Default)]
#[hyperactor::export(
    spawn = true,
    handlers = [
        ShoppingList,
        ClearList,
        GetItemCount<usize>,
    ],
)]
struct ShoppingListActor(HashSet<String>);

// ShoppingListHandler is the trait generated by derive(Handler) above.
// We implement the trait here for the actor, defining a handler for
// each ShoppingList message.
//
// The `forward` attribute installs a handler that forwards messages
// to the `ShoppingListHandler` implementation directly. This can also
// be done manually:
//
// ```ignore
//<ShoppingListActor as ShoppingListHandler>
//     ::handle(self, comm, message).await
// ```
#[async_trait]
#[hyperactor::forward(ShoppingList)]
impl ShoppingListHandler for ShoppingListActor {
    async fn add(&mut self, _cx: &Context<Self>, item: String) -> Result<(), anyhow::Error> {
        eprintln!("insert {}", item);
        self.0.insert(item);
        Ok(())
    }

    async fn remove(&mut self, _cx: &Context<Self>, item: String) -> Result<(), anyhow::Error> {
        eprintln!("remove {}", item);
        self.0.remove(&item);
        Ok(())
    }

    async fn exists(&mut self, _cx: &Context<Self>, item: String) -> Result<bool, anyhow::Error> {
        Ok(self.0.contains(&item))
    }

    async fn list(&mut self, _cx: &Context<Self>) -> Result<Vec<String>, anyhow::Error> {
        Ok(self.0.iter().cloned().collect())
    }
}

#[async_trait]
#[hyperactor::forward(ClearList)]
impl ClearListHandler for ShoppingListActor {
    async fn clear_list(
        &mut self,
        _cx: &Context<Self>,
        reason: String,
    ) -> Result<(), anyhow::Error> {
        eprintln!("clearing list: {}", reason);
        self.0.clear();
        Ok(())
    }
}

#[async_trait]
#[hyperactor::forward(GetItemCount<usize>)]
impl GetItemCountHandler<usize> for ShoppingListActor {
    async fn get_item_count(
        &mut self,
        _cx: &Context<Self>,
        category_filter: String,
    ) -> Result<usize, anyhow::Error> {
        // Simple filter: count items containing the category_filter string
        let count = self
            .0
            .iter()
            .filter(|item| item.contains(&category_filter))
            .count();
        eprintln!("counting items with '{}': {}", category_filter, count);
        Ok(count)
    }
}

// Define an alias actor `ShoppingApi`. Clients can use
// `ActorRef<ShoppingApi>` instead of referencing the concrete
// `ShoppingListActor` directly.
hyperactor::alias!(ShoppingApi, ShoppingList, ClearList, GetItemCount<usize>,);

#[tokio::main]
async fn main() -> Result<(), anyhow::Error> {
    let mut proc = Proc::local();

    // Spawn our actor, and get a handle for rank 0.
    let shopping_list_actor: hyperactor::ActorHandle<ShoppingListActor> =
        proc.spawn("shopping", ()).await?;
    // We attest this is safe because we know this is the id of an
    // actor we just spawned.
    let shopping_api: hyperactor::ActorRef<ShoppingApi> =
        hyperactor::ActorRef::attest(shopping_list_actor.actor_id().clone());
    // We join the system, so that we can send messages to actors.
    let (client, _) = proc.instance("client").unwrap();

    // todo: consider making this a macro to remove the magic names

    // Derive(Handler) generates client methods, which call the
    // remote handler provided an instance (send + open capability),
    // the destination actor, and the method arguments.

    shopping_list_actor.add(&client, "milk".into()).await?;
    // We can perfrom operations through `shopping_api` too.
    shopping_api.add(&client, "eggs".into()).await?;

    println!(
        "got milk? {}",
        shopping_list_actor.exists(&client, "milk".into()).await?
    );
    println!(
        "got yoghurt? {}",
        shopping_list_actor
            .exists(&client, "yoghurt".into())
            .await?
    );

    shopping_list_actor.remove(&client, "milk".into()).await?;
    println!(
        "got milk now? {}",
        shopping_list_actor.exists(&client, "milk".into()).await?
    );

    println!(
        "shopping list: {:?}",
        shopping_list_actor.list(&client).await?
    );

    // Add some more items to test filtering
    shopping_list_actor
        .add(&client, "dairy milk".into())
        .await?;
    shopping_list_actor
        .add(&client, "whole grain bread".into())
        .await?;

    // Test the GetItemCount struct message (call message with reply)
    let dairy_count = shopping_list_actor
        .get_item_count(&client, "dairy".into())
        .await?;
    println!("items containing 'dairy': {}", dairy_count);

    let grain_count = shopping_list_actor
        .get_item_count(&client, "grain".into())
        .await?;
    println!("items containing 'grain': {}", grain_count);

    // Test the ClearList struct message (oneway message)
    shopping_list_actor
        .clear_list(&client, "end of shopping session".into())
        .await?;

    println!(
        "shopping list after clear: {:?}",
        shopping_list_actor.list(&client).await?
    );

    let _ = proc
        .destroy_and_wait::<()>(Duration::from_secs(1), None)
        .await?;
    Ok(())
}
